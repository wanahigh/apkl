{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/zodiase:mdl-assets/src/mdlComponentHandler.js","filenameRelative":"packages/zodiase:mdl-assets/src/mdlComponentHandler.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/zodiase:mdl-assets/src/mdlComponentHandler.js.map","sourceFileName":"packages/zodiase:mdl-assets/src/mdlComponentHandler.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"mdlComponentHandler"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * @license\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n     * A component handler interface using the revealing module design pattern.\n     * More details on this design pattern here:\n     * https://github.com/jasonmayes/mdl-component-design-pattern\n     *\n     * @author Jason Mayes.\n     */ /* exported componentHandler */ // Pre-defining the componentHandler interface, for closure documentation and\n// static verification.\nvar componentHandler = {\n  /**\n   * Searches existing DOM for elements of our component type and upgrades them\n   * if they have not already been upgraded.\n   *\n   * @param {string=} optJsClass the programatic name of the element class we\n   * need to create a new instance of.\n   * @param {string=} optCssClass the name of the CSS class elements of this\n   * type will have.\n   */upgradeDom: function (optJsClass, optCssClass) {},\n  /**\n   * Upgrades a specific element rather than all in the DOM.\n   *\n   * @param {!Element} element The element we wish to upgrade.\n   * @param {string=} optJsClass Optional name of the class we want to upgrade\n   * the element to.\n   */upgradeElement: function (element, optJsClass) {},\n  /**\n   * Upgrades a specific list of elements rather than all in the DOM.\n   *\n   * @param {!Element|!Array<!Element>|!NodeList|!HTMLCollection} elements\n   * The elements we wish to upgrade.\n   */upgradeElements: function (elements) {},\n  /**\n   * Upgrades all registered components found in the current DOM. This is\n   * automatically called on window load.\n   */upgradeAllRegistered: function () {},\n  /**\n   * Allows user to be alerted to any upgrades that are performed for a given\n   * component type\n   *\n   * @param {string} jsClass The class name of the MDL component we wish\n   * to hook into for any upgrades performed.\n   * @param {function(!HTMLElement)} callback The function to call upon an\n   * upgrade. This function should expect 1 parameter - the HTMLElement which\n   * got upgraded.\n   */registerUpgradedCallback: function (jsClass, callback) {},\n  /**\n   * Registers a class for future use and attempts to upgrade existing DOM.\n   *\n   * @param {componentHandler.ComponentConfigPublic} config the registration configuration\n   */register: function (config) {},\n  /**\n   * Downgrade either a given node, an array of nodes, or a NodeList.\n   *\n   * @param {!Node|!Array<!Node>|!NodeList} nodes\n   */downgradeElements: function (nodes) {}\n};\n\ncomponentHandler = function () {\n  'use strict'; /** @type {!Array<componentHandler.ComponentConfig>} */\n\n  var registeredComponents_ = []; /** @type {!Array<componentHandler.Component>} */\n  var createdComponents_ = [];\n  var componentConfigProperty_ = 'mdlComponentConfigInternal_'; /**\n                                                                 * Searches registered components for a class we are interested in using.\n                                                                 * Optionally replaces a match with passed object if specified.\n                                                                 *\n                                                                 * @param {string} name The name of a class we want to use.\n                                                                 * @param {componentHandler.ComponentConfig=} optReplace Optional object to replace match with.\n                                                                 * @return {!Object|boolean}\n                                                                 * @private\n                                                                 */\n\n  function findRegisteredClass_(name, optReplace) {\n    for (var i = 0; i < registeredComponents_.length; i++) {\n      if (registeredComponents_[i].className === name) {\n        if (typeof optReplace !== 'undefined') {\n          registeredComponents_[i] = optReplace;\n        }\n\n        return registeredComponents_[i];\n      }\n    }\n\n    return false;\n  } /**\n     * Returns an array of the classNames of the upgraded classes on the element.\n     *\n     * @param {!Element} element The element to fetch data from.\n     * @return {!Array<string>}\n     * @private\n     */\n\n  function getUpgradedListOfElement_(element) {\n    var dataUpgraded = element.getAttribute('data-upgraded'); // Use `['']` as default value to conform the `,name,name...` style.\n\n    return dataUpgraded === null ? [''] : dataUpgraded.split(',');\n  } /**\n     * Returns true if the given element has already been upgraded for the given\n     * class.\n     *\n     * @param {!Element} element The element we want to check.\n     * @param {string} jsClass The class to check for.\n     * @returns {boolean}\n     * @private\n     */\n\n  function isElementUpgraded_(element, jsClass) {\n    var upgradedList = getUpgradedListOfElement_(element);\n    return upgradedList.indexOf(jsClass) !== -1;\n  } /**\n     * Create an event object.\n     *\n     * @param {string} eventType The type name of the event.\n     * @param {boolean} bubbles Whether the event should bubble up the DOM.\n     * @param {boolean} cancelable Whether the event can be canceled.\n     * @returns {!Event}\n     */\n\n  function createEvent_(eventType, bubbles, cancelable) {\n    if ('CustomEvent' in window && typeof window.CustomEvent === 'function') {\n      return new CustomEvent(eventType, {\n        bubbles: bubbles,\n        cancelable: cancelable\n      });\n    } else {\n      var ev = document.createEvent('Events');\n      ev.initEvent(eventType, bubbles, cancelable);\n      return ev;\n    }\n  } /**\n     * Searches existing DOM for elements of our component type and upgrades them\n     * if they have not already been upgraded.\n     *\n     * @param {string=} optJsClass the programatic name of the element class we\n     * need to create a new instance of.\n     * @param {string=} optCssClass the name of the CSS class elements of this\n     * type will have.\n     */\n\n  function upgradeDomInternal(optJsClass, optCssClass) {\n    if (typeof optJsClass === 'undefined' && typeof optCssClass === 'undefined') {\n      for (var i = 0; i < registeredComponents_.length; i++) {\n        upgradeDomInternal(registeredComponents_[i].className, registeredComponents_[i].cssClass);\n      }\n    } else {\n      var jsClass = /** @type {string} */optJsClass;\n\n      if (typeof optCssClass === 'undefined') {\n        var registeredClass = findRegisteredClass_(jsClass);\n\n        if (registeredClass) {\n          optCssClass = registeredClass.cssClass;\n        }\n      }\n\n      var elements = document.querySelectorAll('.' + optCssClass);\n\n      for (var n = 0; n < elements.length; n++) {\n        upgradeElementInternal(elements[n], jsClass);\n      }\n    }\n  } /**\n     * Upgrades a specific element rather than all in the DOM.\n     *\n     * @param {!Element} element The element we wish to upgrade.\n     * @param {string=} optJsClass Optional name of the class we want to upgrade\n     * the element to.\n     */\n\n  function upgradeElementInternal(element, optJsClass) {\n    // Verify argument type.\n    if (!((typeof element === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(element)) === 'object' && element instanceof Element)) {\n      throw new Error('Invalid argument provided to upgrade MDL element.');\n    } // Allow upgrade to be canceled by canceling emitted event.\n\n\n    var upgradingEv = createEvent_('mdl-componentupgrading', true, true);\n    element.dispatchEvent(upgradingEv);\n\n    if (upgradingEv.defaultPrevented) {\n      return;\n    }\n\n    var upgradedList = getUpgradedListOfElement_(element);\n    var classesToUpgrade = []; // If jsClass is not provided scan the registered components to find the\n    // ones matching the element's CSS classList.\n\n    if (!optJsClass) {\n      var classList = element.classList;\n      registeredComponents_.forEach(function (component) {\n        // Match CSS & Not to be upgraded & Not upgraded.\n        if (classList.contains(component.cssClass) && classesToUpgrade.indexOf(component) === -1 && !isElementUpgraded_(element, component.className)) {\n          classesToUpgrade.push(component);\n        }\n      });\n    } else if (!isElementUpgraded_(element, optJsClass)) {\n      classesToUpgrade.push(findRegisteredClass_(optJsClass));\n    } // Upgrade the element for each classes.\n\n\n    for (var i = 0, n = classesToUpgrade.length, registeredClass; i < n; i++) {\n      registeredClass = classesToUpgrade[i];\n\n      if (registeredClass) {\n        // Mark element as upgraded.\n        upgradedList.push(registeredClass.className);\n        element.setAttribute('data-upgraded', upgradedList.join(','));\n        var instance = new registeredClass.classConstructor(element);\n        instance[componentConfigProperty_] = registeredClass;\n        createdComponents_.push(instance); // Call any callbacks the user has registered with this component type.\n\n        for (var j = 0, m = registeredClass.callbacks.length; j < m; j++) {\n          registeredClass.callbacks[j](element);\n        }\n\n        if (registeredClass.widget) {\n          // Assign per element instance for control over API\n          element[registeredClass.className] = instance;\n        }\n      } else {\n        throw new Error('Unable to find a registered component for the given class.');\n      }\n\n      var upgradedEv = createEvent_('mdl-componentupgraded', true, false);\n      element.dispatchEvent(upgradedEv);\n    }\n  } /**\n     * Upgrades a specific list of elements rather than all in the DOM.\n     *\n     * @param {!Element|!Array<!Element>|!NodeList|!HTMLCollection} elements\n     * The elements we wish to upgrade.\n     */\n\n  function upgradeElementsInternal(elements) {\n    if (!Array.isArray(elements)) {\n      if (elements instanceof Element) {\n        elements = [elements];\n      } else {\n        elements = Array.prototype.slice.call(elements);\n      }\n    }\n\n    for (var i = 0, n = elements.length, element; i < n; i++) {\n      element = elements[i];\n\n      if (element instanceof HTMLElement) {\n        upgradeElementInternal(element);\n\n        if (element.children.length > 0) {\n          upgradeElementsInternal(element.children);\n        }\n      }\n    }\n  } /**\n     * Registers a class for future use and attempts to upgrade existing DOM.\n     *\n     * @param {componentHandler.ComponentConfigPublic} config\n     */\n\n  function registerInternal(config) {\n    // In order to support both Closure-compiled and uncompiled code accessing\n    // this method, we need to allow for both the dot and array syntax for\n    // property access. You'll therefore see the `foo.bar || foo['bar']`\n    // pattern repeated across this method.\n    var widgetMissing = typeof config.widget === 'undefined' && typeof config['widget'] === 'undefined';\n    var widget = true;\n\n    if (!widgetMissing) {\n      widget = config.widget || config['widget'];\n    }\n\n    var newConfig = /** @type {componentHandler.ComponentConfig} */{\n      classConstructor: config.constructor || config['constructor'],\n      className: config.classAsString || config['classAsString'],\n      cssClass: config.cssClass || config['cssClass'],\n      widget: widget,\n      callbacks: []\n    };\n    registeredComponents_.forEach(function (item) {\n      if (item.cssClass === newConfig.cssClass) {\n        throw new Error('The provided cssClass has already been registered: ' + item.cssClass);\n      }\n\n      if (item.className === newConfig.className) {\n        throw new Error('The provided className has already been registered');\n      }\n    });\n\n    if (config.constructor.prototype.hasOwnProperty(componentConfigProperty_)) {\n      throw new Error('MDL component classes must not have ' + componentConfigProperty_ + ' defined as a property.');\n    }\n\n    var found = findRegisteredClass_(config.classAsString, newConfig);\n\n    if (!found) {\n      registeredComponents_.push(newConfig);\n    }\n  } /**\n     * Allows user to be alerted to any upgrades that are performed for a given\n     * component type\n     *\n     * @param {string} jsClass The class name of the MDL component we wish\n     * to hook into for any upgrades performed.\n     * @param {function(!HTMLElement)} callback The function to call upon an\n     * upgrade. This function should expect 1 parameter - the HTMLElement which\n     * got upgraded.\n     */\n\n  function registerUpgradedCallbackInternal(jsClass, callback) {\n    var regClass = findRegisteredClass_(jsClass);\n\n    if (regClass) {\n      regClass.callbacks.push(callback);\n    }\n  } /**\n     * Upgrades all registered components found in the current DOM. This is\n     * automatically called on window load.\n     */\n\n  function upgradeAllRegisteredInternal() {\n    for (var n = 0; n < registeredComponents_.length; n++) {\n      upgradeDomInternal(registeredComponents_[n].className);\n    }\n  } /**\n     * Check the component for the downgrade method.\n     * Execute if found.\n     * Remove component from createdComponents list.\n     *\n     * @param {?componentHandler.Component} component\n     */\n\n  function deconstructComponentInternal(component) {\n    if (component) {\n      var componentIndex = createdComponents_.indexOf(component);\n      createdComponents_.splice(componentIndex, 1);\n      var upgrades = component.element_.getAttribute('data-upgraded').split(',');\n      var componentPlace = upgrades.indexOf(component[componentConfigProperty_].classAsString);\n      upgrades.splice(componentPlace, 1);\n      component.element_.setAttribute('data-upgraded', upgrades.join(','));\n      var ev = createEvent_('mdl-componentdowngraded', true, false);\n      component.element_.dispatchEvent(ev);\n    }\n  } /**\n     * Downgrade either a given node, an array of nodes, or a NodeList.\n     *\n     * @param {!Node|!Array<!Node>|!NodeList} nodes\n     */\n\n  function downgradeNodesInternal(nodes) {\n    /**\n     * Auxiliary function to downgrade a single node.\n     * @param  {!Node} node the node to be downgraded\n     */var downgradeNode = function (node) {\n      createdComponents_.filter(function (item) {\n        return item.element_ === node;\n      }).forEach(deconstructComponentInternal);\n    };\n\n    if (nodes instanceof Array || nodes instanceof NodeList) {\n      for (var n = 0; n < nodes.length; n++) {\n        downgradeNode(nodes[n]);\n      }\n    } else if (nodes instanceof Node) {\n      downgradeNode(nodes);\n    } else {\n      throw new Error('Invalid argument provided to downgrade MDL nodes.');\n    }\n  } // Now return the functions that should be made public with their publicly\n  // facing names...\n\n\n  return {\n    upgradeDom: upgradeDomInternal,\n    upgradeElement: upgradeElementInternal,\n    upgradeElements: upgradeElementsInternal,\n    upgradeAllRegistered: upgradeAllRegisteredInternal,\n    registerUpgradedCallback: registerUpgradedCallbackInternal,\n    register: registerInternal,\n    downgradeElements: downgradeNodesInternal\n  };\n}(); /**\n      * Describes the type of a registered component type managed by\n      * componentHandler. Provided for benefit of the Closure compiler.\n      *\n      * @typedef {{\n      *   constructor: Function,\n      *   classAsString: string,\n      *   cssClass: string,\n      *   widget: (string|boolean|undefined)\n      * }}\n      */\n\ncomponentHandler.ComponentConfigPublic; // jshint ignore:line\n/**\n * Describes the type of a registered component type managed by\n * componentHandler. Provided for benefit of the Closure compiler.\n *\n * @typedef {{\n *   constructor: !Function,\n *   className: string,\n *   cssClass: string,\n *   widget: (string|boolean),\n *   callbacks: !Array<function(!HTMLElement)>\n * }}\n */\ncomponentHandler.ComponentConfig; // jshint ignore:line\n/**\n * Created component (i.e., upgraded element) type as managed by\n * componentHandler. Provided for benefit of the Closure compiler.\n *\n * @typedef {{\n *   element_: !HTMLElement,\n *   className: string,\n *   classAsString: string,\n *   cssClass: string,\n *   widget: string\n * }}\n */\ncomponentHandler.Component; // jshint ignore:line\n// Export all symbols, for the benefit of Closure compiler.\n// No effect on uncompiled code.\n\ncomponentHandler['upgradeDom'] = componentHandler.upgradeDom;\ncomponentHandler['upgradeElement'] = componentHandler.upgradeElement;\ncomponentHandler['upgradeElements'] = componentHandler.upgradeElements;\ncomponentHandler['upgradeAllRegistered'] = componentHandler.upgradeAllRegistered;\ncomponentHandler['registerUpgradedCallback'] = componentHandler.registerUpgradedCallback;\ncomponentHandler['register'] = componentHandler.register;\ncomponentHandler['downgradeElements'] = componentHandler.downgradeElements;\nwindow.componentHandler = componentHandler;\nwindow['componentHandler'] = componentHandler;\nwindow.addEventListener('load', function () {\n  'use strict'; /**\n                 * Performs a \"Cutting the mustard\" test. If the browser supports the features\n                 * tested, adds a mdl-js class to the <html> element. It then upgrades all MDL\n                 * components requiring JavaScript.\n                 */\n\n  if ('classList' in document.createElement('div') && 'querySelector' in document && 'addEventListener' in window && Array.prototype.forEach) {\n    document.documentElement.classList.add('mdl-js');\n    componentHandler.upgradeAllRegistered();\n  } else {\n    /**\n     * Dummy function to avoid JS errors.\n     */componentHandler.upgradeElement = function () {}; /**\n                                                          * Dummy function to avoid JS errors.\n                                                          */\n\n    componentHandler.register = function () {};\n  }\n});","map":{"version":3,"sources":["packages/zodiase:mdl-assets/src/mdlComponentHandler.js"],"names":["componentHandler","upgradeDom","optJsClass","optCssClass","upgradeElement","element","upgradeElements","elements","upgradeAllRegistered","registerUpgradedCallback","jsClass","callback","register","config","downgradeElements","nodes","registeredComponents_","createdComponents_","componentConfigProperty_","findRegisteredClass_","name","optReplace","i","length","className","getUpgradedListOfElement_","dataUpgraded","getAttribute","split","isElementUpgraded_","upgradedList","indexOf","createEvent_","eventType","bubbles","cancelable","window","CustomEvent","ev","document","createEvent","initEvent","upgradeDomInternal","cssClass","registeredClass","querySelectorAll","n","upgradeElementInternal","Element","Error","upgradingEv","dispatchEvent","defaultPrevented","classesToUpgrade","classList","forEach","component","contains","push","setAttribute","join","instance","classConstructor","j","m","callbacks","widget","upgradedEv","upgradeElementsInternal","Array","isArray","prototype","slice","call","HTMLElement","children","registerInternal","widgetMissing","newConfig","constructor","classAsString","item","hasOwnProperty","found","registerUpgradedCallbackInternal","regClass","upgradeAllRegisteredInternal","deconstructComponentInternal","componentIndex","splice","upgrades","element_","componentPlace","downgradeNodesInternal","downgradeNode","node","filter","NodeList","Node","ComponentConfigPublic","ComponentConfig","Component","addEventListener","createElement","documentElement","add"],"mappings":"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","file":"packages/zodiase:mdl-assets/src/mdlComponentHandler.js.map","sourcesContent":["/**\n * @license\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A component handler interface using the revealing module design pattern.\n * More details on this design pattern here:\n * https://github.com/jasonmayes/mdl-component-design-pattern\n *\n * @author Jason Mayes.\n */\n/* exported componentHandler */\n\n// Pre-defining the componentHandler interface, for closure documentation and\n// static verification.\nvar componentHandler = {\n  /**\n   * Searches existing DOM for elements of our component type and upgrades them\n   * if they have not already been upgraded.\n   *\n   * @param {string=} optJsClass the programatic name of the element class we\n   * need to create a new instance of.\n   * @param {string=} optCssClass the name of the CSS class elements of this\n   * type will have.\n   */\n  upgradeDom: function(optJsClass, optCssClass) {},\n  /**\n   * Upgrades a specific element rather than all in the DOM.\n   *\n   * @param {!Element} element The element we wish to upgrade.\n   * @param {string=} optJsClass Optional name of the class we want to upgrade\n   * the element to.\n   */\n  upgradeElement: function(element, optJsClass) {},\n  /**\n   * Upgrades a specific list of elements rather than all in the DOM.\n   *\n   * @param {!Element|!Array<!Element>|!NodeList|!HTMLCollection} elements\n   * The elements we wish to upgrade.\n   */\n  upgradeElements: function(elements) {},\n  /**\n   * Upgrades all registered components found in the current DOM. This is\n   * automatically called on window load.\n   */\n  upgradeAllRegistered: function() {},\n  /**\n   * Allows user to be alerted to any upgrades that are performed for a given\n   * component type\n   *\n   * @param {string} jsClass The class name of the MDL component we wish\n   * to hook into for any upgrades performed.\n   * @param {function(!HTMLElement)} callback The function to call upon an\n   * upgrade. This function should expect 1 parameter - the HTMLElement which\n   * got upgraded.\n   */\n  registerUpgradedCallback: function(jsClass, callback) {},\n  /**\n   * Registers a class for future use and attempts to upgrade existing DOM.\n   *\n   * @param {componentHandler.ComponentConfigPublic} config the registration configuration\n   */\n  register: function(config) {},\n  /**\n   * Downgrade either a given node, an array of nodes, or a NodeList.\n   *\n   * @param {!Node|!Array<!Node>|!NodeList} nodes\n   */\n  downgradeElements: function(nodes) {}\n};\n\ncomponentHandler = (function() {\n  'use strict';\n\n  /** @type {!Array<componentHandler.ComponentConfig>} */\n  var registeredComponents_ = [];\n\n  /** @type {!Array<componentHandler.Component>} */\n  var createdComponents_ = [];\n\n  var componentConfigProperty_ = 'mdlComponentConfigInternal_';\n\n  /**\n   * Searches registered components for a class we are interested in using.\n   * Optionally replaces a match with passed object if specified.\n   *\n   * @param {string} name The name of a class we want to use.\n   * @param {componentHandler.ComponentConfig=} optReplace Optional object to replace match with.\n   * @return {!Object|boolean}\n   * @private\n   */\n  function findRegisteredClass_(name, optReplace) {\n    for (var i = 0; i < registeredComponents_.length; i++) {\n      if (registeredComponents_[i].className === name) {\n        if (typeof optReplace !== 'undefined') {\n          registeredComponents_[i] = optReplace;\n        }\n        return registeredComponents_[i];\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns an array of the classNames of the upgraded classes on the element.\n   *\n   * @param {!Element} element The element to fetch data from.\n   * @return {!Array<string>}\n   * @private\n   */\n  function getUpgradedListOfElement_(element) {\n    var dataUpgraded = element.getAttribute('data-upgraded');\n    // Use `['']` as default value to conform the `,name,name...` style.\n    return dataUpgraded === null ? [''] : dataUpgraded.split(',');\n  }\n\n  /**\n   * Returns true if the given element has already been upgraded for the given\n   * class.\n   *\n   * @param {!Element} element The element we want to check.\n   * @param {string} jsClass The class to check for.\n   * @returns {boolean}\n   * @private\n   */\n  function isElementUpgraded_(element, jsClass) {\n    var upgradedList = getUpgradedListOfElement_(element);\n    return upgradedList.indexOf(jsClass) !== -1;\n  }\n\n  /**\n   * Create an event object.\n   *\n   * @param {string} eventType The type name of the event.\n   * @param {boolean} bubbles Whether the event should bubble up the DOM.\n   * @param {boolean} cancelable Whether the event can be canceled.\n   * @returns {!Event}\n   */\n  function createEvent_(eventType, bubbles, cancelable) {\n    if ('CustomEvent' in window && typeof window.CustomEvent === 'function') {\n      return new CustomEvent(eventType, {\n        bubbles: bubbles,\n        cancelable: cancelable\n      });\n    } else {\n      var ev = document.createEvent('Events');\n      ev.initEvent(eventType, bubbles, cancelable);\n      return ev;\n    }\n  }\n\n  /**\n   * Searches existing DOM for elements of our component type and upgrades them\n   * if they have not already been upgraded.\n   *\n   * @param {string=} optJsClass the programatic name of the element class we\n   * need to create a new instance of.\n   * @param {string=} optCssClass the name of the CSS class elements of this\n   * type will have.\n   */\n  function upgradeDomInternal(optJsClass, optCssClass) {\n    if (typeof optJsClass === 'undefined' &&\n        typeof optCssClass === 'undefined') {\n      for (var i = 0; i < registeredComponents_.length; i++) {\n        upgradeDomInternal(registeredComponents_[i].className,\n            registeredComponents_[i].cssClass);\n      }\n    } else {\n      var jsClass = /** @type {string} */ (optJsClass);\n      if (typeof optCssClass === 'undefined') {\n        var registeredClass = findRegisteredClass_(jsClass);\n        if (registeredClass) {\n          optCssClass = registeredClass.cssClass;\n        }\n      }\n\n      var elements = document.querySelectorAll('.' + optCssClass);\n      for (var n = 0; n < elements.length; n++) {\n        upgradeElementInternal(elements[n], jsClass);\n      }\n    }\n  }\n\n  /**\n   * Upgrades a specific element rather than all in the DOM.\n   *\n   * @param {!Element} element The element we wish to upgrade.\n   * @param {string=} optJsClass Optional name of the class we want to upgrade\n   * the element to.\n   */\n  function upgradeElementInternal(element, optJsClass) {\n    // Verify argument type.\n    if (!(typeof element === 'object' && element instanceof Element)) {\n      throw new Error('Invalid argument provided to upgrade MDL element.');\n    }\n    // Allow upgrade to be canceled by canceling emitted event.\n    var upgradingEv = createEvent_('mdl-componentupgrading', true, true);\n    element.dispatchEvent(upgradingEv);\n    if (upgradingEv.defaultPrevented) {\n      return;\n    }\n\n    var upgradedList = getUpgradedListOfElement_(element);\n    var classesToUpgrade = [];\n    // If jsClass is not provided scan the registered components to find the\n    // ones matching the element's CSS classList.\n    if (!optJsClass) {\n      var classList = element.classList;\n      registeredComponents_.forEach(function(component) {\n        // Match CSS & Not to be upgraded & Not upgraded.\n        if (classList.contains(component.cssClass) &&\n            classesToUpgrade.indexOf(component) === -1 &&\n            !isElementUpgraded_(element, component.className)) {\n          classesToUpgrade.push(component);\n        }\n      });\n    } else if (!isElementUpgraded_(element, optJsClass)) {\n      classesToUpgrade.push(findRegisteredClass_(optJsClass));\n    }\n\n    // Upgrade the element for each classes.\n    for (var i = 0, n = classesToUpgrade.length, registeredClass; i < n; i++) {\n      registeredClass = classesToUpgrade[i];\n      if (registeredClass) {\n        // Mark element as upgraded.\n        upgradedList.push(registeredClass.className);\n        element.setAttribute('data-upgraded', upgradedList.join(','));\n        var instance = new registeredClass.classConstructor(element);\n        instance[componentConfigProperty_] = registeredClass;\n        createdComponents_.push(instance);\n        // Call any callbacks the user has registered with this component type.\n        for (var j = 0, m = registeredClass.callbacks.length; j < m; j++) {\n          registeredClass.callbacks[j](element);\n        }\n\n        if (registeredClass.widget) {\n          // Assign per element instance for control over API\n          element[registeredClass.className] = instance;\n        }\n      } else {\n        throw new Error(\n          'Unable to find a registered component for the given class.');\n      }\n\n      var upgradedEv = createEvent_('mdl-componentupgraded', true, false);\n      element.dispatchEvent(upgradedEv);\n    }\n  }\n\n  /**\n   * Upgrades a specific list of elements rather than all in the DOM.\n   *\n   * @param {!Element|!Array<!Element>|!NodeList|!HTMLCollection} elements\n   * The elements we wish to upgrade.\n   */\n  function upgradeElementsInternal(elements) {\n    if (!Array.isArray(elements)) {\n      if (elements instanceof Element) {\n        elements = [elements];\n      } else {\n        elements = Array.prototype.slice.call(elements);\n      }\n    }\n    for (var i = 0, n = elements.length, element; i < n; i++) {\n      element = elements[i];\n      if (element instanceof HTMLElement) {\n        upgradeElementInternal(element);\n        if (element.children.length > 0) {\n          upgradeElementsInternal(element.children);\n        }\n      }\n    }\n  }\n\n  /**\n   * Registers a class for future use and attempts to upgrade existing DOM.\n   *\n   * @param {componentHandler.ComponentConfigPublic} config\n   */\n  function registerInternal(config) {\n    // In order to support both Closure-compiled and uncompiled code accessing\n    // this method, we need to allow for both the dot and array syntax for\n    // property access. You'll therefore see the `foo.bar || foo['bar']`\n    // pattern repeated across this method.\n    var widgetMissing = (typeof config.widget === 'undefined' &&\n        typeof config['widget'] === 'undefined');\n    var widget = true;\n\n    if (!widgetMissing) {\n      widget = config.widget || config['widget'];\n    }\n\n    var newConfig = /** @type {componentHandler.ComponentConfig} */ ({\n      classConstructor: config.constructor || config['constructor'],\n      className: config.classAsString || config['classAsString'],\n      cssClass: config.cssClass || config['cssClass'],\n      widget: widget,\n      callbacks: []\n    });\n\n    registeredComponents_.forEach(function(item) {\n      if (item.cssClass === newConfig.cssClass) {\n        throw new Error('The provided cssClass has already been registered: ' + item.cssClass);\n      }\n      if (item.className === newConfig.className) {\n        throw new Error('The provided className has already been registered');\n      }\n    });\n\n    if (config.constructor.prototype\n        .hasOwnProperty(componentConfigProperty_)) {\n      throw new Error(\n          'MDL component classes must not have ' + componentConfigProperty_ +\n          ' defined as a property.');\n    }\n\n    var found = findRegisteredClass_(config.classAsString, newConfig);\n\n    if (!found) {\n      registeredComponents_.push(newConfig);\n    }\n  }\n\n  /**\n   * Allows user to be alerted to any upgrades that are performed for a given\n   * component type\n   *\n   * @param {string} jsClass The class name of the MDL component we wish\n   * to hook into for any upgrades performed.\n   * @param {function(!HTMLElement)} callback The function to call upon an\n   * upgrade. This function should expect 1 parameter - the HTMLElement which\n   * got upgraded.\n   */\n  function registerUpgradedCallbackInternal(jsClass, callback) {\n    var regClass = findRegisteredClass_(jsClass);\n    if (regClass) {\n      regClass.callbacks.push(callback);\n    }\n  }\n\n  /**\n   * Upgrades all registered components found in the current DOM. This is\n   * automatically called on window load.\n   */\n  function upgradeAllRegisteredInternal() {\n    for (var n = 0; n < registeredComponents_.length; n++) {\n      upgradeDomInternal(registeredComponents_[n].className);\n    }\n  }\n\n  /**\n   * Check the component for the downgrade method.\n   * Execute if found.\n   * Remove component from createdComponents list.\n   *\n   * @param {?componentHandler.Component} component\n   */\n  function deconstructComponentInternal(component) {\n    if (component) {\n      var componentIndex = createdComponents_.indexOf(component);\n      createdComponents_.splice(componentIndex, 1);\n\n      var upgrades = component.element_.getAttribute('data-upgraded').split(',');\n      var componentPlace = upgrades.indexOf(component[componentConfigProperty_].classAsString);\n      upgrades.splice(componentPlace, 1);\n      component.element_.setAttribute('data-upgraded', upgrades.join(','));\n\n      var ev = createEvent_('mdl-componentdowngraded', true, false);\n      component.element_.dispatchEvent(ev);\n    }\n  }\n\n  /**\n   * Downgrade either a given node, an array of nodes, or a NodeList.\n   *\n   * @param {!Node|!Array<!Node>|!NodeList} nodes\n   */\n  function downgradeNodesInternal(nodes) {\n    /**\n     * Auxiliary function to downgrade a single node.\n     * @param  {!Node} node the node to be downgraded\n     */\n    var downgradeNode = function(node) {\n      createdComponents_.filter(function(item) {\n        return item.element_ === node;\n      }).forEach(deconstructComponentInternal);\n    };\n    if (nodes instanceof Array || nodes instanceof NodeList) {\n      for (var n = 0; n < nodes.length; n++) {\n        downgradeNode(nodes[n]);\n      }\n    } else if (nodes instanceof Node) {\n      downgradeNode(nodes);\n    } else {\n      throw new Error('Invalid argument provided to downgrade MDL nodes.');\n    }\n  }\n\n  // Now return the functions that should be made public with their publicly\n  // facing names...\n  return {\n    upgradeDom: upgradeDomInternal,\n    upgradeElement: upgradeElementInternal,\n    upgradeElements: upgradeElementsInternal,\n    upgradeAllRegistered: upgradeAllRegisteredInternal,\n    registerUpgradedCallback: registerUpgradedCallbackInternal,\n    register: registerInternal,\n    downgradeElements: downgradeNodesInternal\n  };\n})();\n\n/**\n * Describes the type of a registered component type managed by\n * componentHandler. Provided for benefit of the Closure compiler.\n *\n * @typedef {{\n *   constructor: Function,\n *   classAsString: string,\n *   cssClass: string,\n *   widget: (string|boolean|undefined)\n * }}\n */\ncomponentHandler.ComponentConfigPublic;  // jshint ignore:line\n\n/**\n * Describes the type of a registered component type managed by\n * componentHandler. Provided for benefit of the Closure compiler.\n *\n * @typedef {{\n *   constructor: !Function,\n *   className: string,\n *   cssClass: string,\n *   widget: (string|boolean),\n *   callbacks: !Array<function(!HTMLElement)>\n * }}\n */\ncomponentHandler.ComponentConfig;  // jshint ignore:line\n\n/**\n * Created component (i.e., upgraded element) type as managed by\n * componentHandler. Provided for benefit of the Closure compiler.\n *\n * @typedef {{\n *   element_: !HTMLElement,\n *   className: string,\n *   classAsString: string,\n *   cssClass: string,\n *   widget: string\n * }}\n */\ncomponentHandler.Component;  // jshint ignore:line\n\n// Export all symbols, for the benefit of Closure compiler.\n// No effect on uncompiled code.\ncomponentHandler['upgradeDom'] = componentHandler.upgradeDom;\ncomponentHandler['upgradeElement'] = componentHandler.upgradeElement;\ncomponentHandler['upgradeElements'] = componentHandler.upgradeElements;\ncomponentHandler['upgradeAllRegistered'] =\n    componentHandler.upgradeAllRegistered;\ncomponentHandler['registerUpgradedCallback'] =\n    componentHandler.registerUpgradedCallback;\ncomponentHandler['register'] = componentHandler.register;\ncomponentHandler['downgradeElements'] = componentHandler.downgradeElements;\nwindow.componentHandler = componentHandler;\nwindow['componentHandler'] = componentHandler;\n\nwindow.addEventListener('load', function() {\n  'use strict';\n\n  /**\n   * Performs a \"Cutting the mustard\" test. If the browser supports the features\n   * tested, adds a mdl-js class to the <html> element. It then upgrades all MDL\n   * components requiring JavaScript.\n   */\n  if ('classList' in document.createElement('div') &&\n      'querySelector' in document &&\n      'addEventListener' in window && Array.prototype.forEach) {\n    document.documentElement.classList.add('mdl-js');\n    componentHandler.upgradeAllRegistered();\n  } else {\n    /**\n     * Dummy function to avoid JS errors.\n     */\n    componentHandler.upgradeElement = function() {};\n    /**\n     * Dummy function to avoid JS errors.\n     */\n    componentHandler.register = function() {};\n  }\n});\n"]},"hash":"50f2e95c2274efdf212a7e5658f9beb2ae25c938"}
