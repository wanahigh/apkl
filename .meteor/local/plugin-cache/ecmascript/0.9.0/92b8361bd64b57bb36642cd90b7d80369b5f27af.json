{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/zodiase:mdl-assets/scripts/imports/pqueue.js","filenameRelative":"packages/zodiase:mdl-assets/scripts/imports/pqueue.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/zodiase:mdl-assets/scripts/imports/pqueue.js.map","sourceFileName":"packages/zodiase:mdl-assets/scripts/imports/pqueue.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"pqueue"},"ignored":false,"code":"/*!\r\n * Process Queue v2.4.3 r1\r\n * https://github.com/Zodiase/PQUEUE\r\n *\r\n * Copyright 2013 Xingchen Hong\r\n * Released under the MIT license\r\n * https://raw.github.com/Zodiase/PQUEUE/master/LICENSE\r\n *\r\n * Date: 2014-02-09 10:03\r\n */ /*\r\n    Change Log:\r\n         Fixed a bug when connecting to a parent.\r\n         Added a predefined process PQUEUE_IDLE for easy access.\r\n         Added an option to turn off console logs.\r\n    */ // add ';' to seperate from previous code clips.\nfunction microtime(get_as_float) {\n    var now = new Date().getTime() / 1000;\n    var s = parseInt(now, 10);\n    return get_as_float ? now : Math.round((now - s) * 1000) / 1000 + ' ' + s;\n}\n\nvar startTime = microtime(true);\n\nfunction elapsedTime() {\n    return microtime(true) - startTime;\n}\n\nfunction log(msg) {\n    console.log('@' + (elapsedTime().toString(10) + '        ').substr(0, 8) + ', PQUEUE: ' + msg);\n}\n\nfunction warn(msg) {\n    console.warn('@' + (elapsedTime().toString(10) + '        ').substr(0, 8) + ', PQUEUE: ' + msg);\n}\n\nfunction isArray(obj) {\n    if (typeof obj !== 'object') return false;\n    if (typeof obj.constructor !== 'function') return false;\n    if (typeof obj.constructor.name !== 'string') return false;\n    return obj.constructor.name === 'Array';\n} // a stack for back-track to queues\n\n\nvar queueStack = []; // this function returns a pqueue object\n\nvar PQUEUE = function () {\n    \"use strict\";\n\n    var parent = null,\n        processArray = [],\n        initialProcessID = 0,\n        queueName = '',\n        arg1Type = typeof arguments[0],\n        arg2Type = typeof arguments[1],\n        arg3Type = typeof arguments[2],\n        arg4Type = typeof arguments[3];\n\n    switch (arguments.length) {\n        case 1:\n            if (arg1Type === 'string') {\n                // PQUEUE(string queueName)\n                return queueStack[arguments[0]];\n            } else if (arg1Type === 'object') {\n                if (isArray(arguments[0])) {\n                    // PQUEUE(object processArray)\n                    processArray = arguments[0];\n                } else if (isArray(arguments[0].processArray)) {\n                    parent = typeof arguments[0].parent === 'object' ? arguments[0].parent : null;\n                    processArray = arguments[0].processArray;\n                    initialProcessID = typeof arguments[0].initialProcessID === 'number' ? arguments[0].initialProcessID : 0;\n                    queueName = typeof arguments[0].queueName === 'string' ? arguments[0].queueName : '';\n                } else {\n                    return null;\n                }\n            } else {\n                return null;\n            }\n\n            break;\n\n        case 2:\n            if (arg1Type === 'object' && arg2Type === 'object') {\n                // PQUEUE(object parentQueue, object processArray)\n                parent = arguments[0];\n                processArray = arguments[1];\n                initialProcessID = 0;\n                queueName = '';\n            } else if (arg1Type === 'object' && arg2Type === 'number') {\n                // PQUEUE(object processArray, number initialProcessID)\n                parent = null;\n                processArray = arguments[0];\n                initialProcessID = arguments[1];\n                queueName = '';\n            } else if (arg1Type === 'object' && arg2Type === 'string') {\n                // PQUEUE(object processArray, string queueName)\n                parent = null;\n                processArray = arguments[0];\n                initialProcessID = 0;\n                queueName = arguments[1];\n            } else {\n                return null;\n            }\n\n            break;\n\n        case 3:\n            if (arg1Type === 'object' && arg2Type === 'object' && arg3Type === 'number') {\n                // PQUEUE(object parentQueue, object processArray, number initialProcessID)\n                parent = arguments[0];\n                processArray = arguments[1];\n                initialProcessID = arguments[2];\n                queueName = '';\n            } else if (arg1Type === 'object' && arg2Type === 'object' && arg3Type === 'string') {\n                // PQUEUE(object parentQueue, object processArray, string queueName)\n                parent = arguments[0];\n                processArray = arguments[1];\n                initialProcessID = 0;\n                queueName = arguments[2];\n            } else if (arg1Type === 'object' && arg2Type === 'number' && arg3Type === 'string') {\n                // PQUEUE(object processArray, number initialProcessID, string queueName)\n                parent = null;\n                processArray = arguments[0];\n                initialProcessID = arguments[1];\n                queueName = arguments[2];\n            } else {\n                return null;\n            }\n\n            break;\n\n        case 4:\n            if (arg1Type === 'object' && arg2Type === 'object' && arg3Type === 'number' && arg4Type === 'string') {\n                // PQUEUE(object parentQueue, object processArray, number initialProcessID, string queueName)\n                parent = arguments[0];\n                processArray = arguments[1];\n                initialProcessID = arguments[2];\n                queueName = arguments[3];\n            } else {\n                return null;\n            }\n\n            break;\n\n        default:\n            return null;\n    } // filter init process id\n\n\n    if (typeof initialProcessID !== 'number') initialProcessID = 0;\n    log('Instantiating new process queue.'); // parameter check\n\n    if (typeof processArray !== 'object') {\n        warn('Invalid argument[1]. Expecting an Object.');\n        warn('Returning NULL.'); // 'return;' returns undefined\n\n        return null;\n    }\n\n    log('Generating new process queue object.'); // local copy of core data\n\n    var PQ = {\n        // core clock used to fire ticks\n        'clock': false,\n        // back reference to its parent queue if available\n        'parent': parent && typeof parent === 'object' && parent.PQUEUE ? parent : null,\n        // name of queue\n        'name': '',\n        /**\n         * flags indicating queue status\n         *     bit[0]  indicates a process is running\n         *     bit[1]  indicates the queue is handling one tick\n         *     bit[2]  indicates the queue is booted up but not yet stopped\n         *     bit[3]  indicates the queue should get to the next process automatically\n         *     bit[4]  indicates the queue is paused and waiting for a resume call\n         *     bit[5]  indicates a general error\n         *     bit[6]  indicates pc underflow\n         *     bit[7]  indicates pc overflow\n         *     bit[8]  indicates pc at halt\n         *     bit[9]  indicates pc at barrier\n         *     bit[10] indicates pc at no-op\n         */'status': 0,\n        // message array for errors\n        'errorMessages': [],\n        // array of processes\n        'processStack': [],\n        // fully-associative array used to find the index of a process\n        'processIndexs': [],\n        // index of the next process\n        'processCounter': 0,\n        // pointer to the next process\n        'nextProcess': null,\n        // storage for processes\n        'sharedHeap': {},\n        /**\n         * waker stack is used to store resume call timers so that\n         * when a resume call is called before the timer expires,\n         * the rest timer won't affect the queue\n         */'wakerStack': []\n    },\n        // flag constants\n    FLAG_RUNNING = 0x001,\n        // 0000 0000 0001\n    FLAG_TICKING = 0x002,\n        // 0000 0000 0010\n    FLAG_BOOTED = 0x004,\n        // 0000 0000 0100\n    FLAG_PAUSED = 0x008,\n        // 0000 0000 1000\n    FLAG_GENERR = 0x010,\n        // 0000 0001 0000\n    FLAG_PCUNDER = 0x020,\n        // 0000 0010 0000\n    FLAG_PCOVER = 0x040,\n        // 0000 0100 0000\n    FLAG_PCHALT = 0x080,\n        // 0000 1000 0000\n    FLAG_PCBAR = 0x100,\n        // 0001 0000 0000\n    FLAG_PCNOOP = 0x200,\n        // 0010 0000 0000\n    // interface object passed to processes\n    api = {\n        'heap': PQ.sharedHeap,\n        'heap_dump': dumpSharedHeap,\n        'pause': function (time) {\n            /**\n             * a wait call can only be made when the process is executing\n             * and it should not be made twice\n             */if (queueIsRunning() && !queueIsPaused()) pauseQueue(time);\n        },\n        'resume': function () {\n            /**\n             * however, a resume call can be made within the process right\n             * after the pause call, or, at a later time\n             * a resume call only clears the pause flag so that the clock\n             * is again effective to the queue\n             */if (queueIsPaused()) resumeQueue();\n        },\n        'pc': {\n            'increment': pcIncrement,\n            'decrement': pcDecrement,\n            'offset': pcOffset,\n            'goto': pcGoto,\n            'locate': pcReference,\n            'valueOf': valueOfPC,\n            'toString': PCtoString\n        },\n        'isPaused': function () {\n            return queueIsPaused();\n        },\n        // the so-called parent is actually the api object of the parent queue\n        'parent': PQ.parent,\n        // this is necessary for parent check to recognize a pqueue object\n        'PQUEUE': true\n    },\n        // wrapper object returned to parent scripts\n    wrapper = {\n        'boot': function () {\n            bootQueue();\n            return wrapper;\n        },\n        'halt': function () {\n            haltQueue();\n            return wrapper;\n        },\n        'reset': function () {\n            resetQueue();\n            return wrapper;\n        }\n    }; /* macro functions */ // clock related functions\n\n    function enableClock() {\n        if (PQ.clock === false) {\n            // keep calling tick as fast as possible\n            PQ.clock = setInterval(tick, 0);\n        }\n    }\n\n    function disableClock() {\n        if (PQ.clock !== false) {\n            // stop queue clock\n            clearInterval(PQ.clock);\n            PQ.clock = false;\n        }\n    } // heap related functions\n    /**\n     * this function returns a string representing\n     * contents in shared heap\n     */\n\n    function dumpSharedHeap() {\n        var result = '';\n\n        for (var key in PQ.sharedHeap) {\n            if (result !== '') result += ', \\n';\n            result += key + ':' + PQ.sharedHeap[key];\n        }\n\n        return '{\\n' + result + '\\n}';\n    } /**\n       * this function removes everything in the heap\n       */\n\n    function cleanSharedHeap() {\n        // may cause memory leak but let's keep it this way for now\n        PQ.sharedHeap.length = 0;\n    } // <<< status related functions\n    /**\n     * this the core function handling status bits\n     * the rest are macros using this function\n     */\n\n    function _statIs(setValue, flag) {\n        var returnValue = Boolean(PQ.status & flag);\n\n        if (setValue !== undefined) {\n            if (setValue) PQ.status |= flag;else PQ.status &= ~flag;\n        }\n\n        return returnValue;\n    }\n\n    function queueIsRunning(setValue) {\n        return _statIs(setValue, FLAG_RUNNING);\n    }\n\n    function queueIsTicking(setValue) {\n        return _statIs(setValue, FLAG_TICKING);\n    }\n\n    function queueIsBooted(setValue) {\n        return _statIs(setValue, FLAG_BOOTED);\n    }\n\n    function queueIsPaused(setValue) {\n        return _statIs(setValue, FLAG_PAUSED);\n    }\n\n    function queueError(setValue) {\n        return _statIs(setValue, FLAG_GENERR);\n    }\n\n    function pcUnderflow(setValue) {\n        return _statIs(setValue, FLAG_PCUNDER);\n    }\n\n    function pcOverflow(setValue) {\n        return _statIs(setValue, FLAG_PCOVER);\n    }\n\n    function pcAtHalt(setValue) {\n        return _statIs(setValue, FLAG_PCHALT);\n    }\n\n    function pcAtBarrier(setValue) {\n        return _statIs(setValue, FLAG_PCBAR);\n    }\n\n    function pcAtNoOp(setValue) {\n        return _statIs(setValue, FLAG_PCNOOP);\n    } /**\n       * this function clears all flags related to pc\n       * such as pcOverflow and pcHitBarrier, etc\n       */\n\n    function clearPcStatus() {\n        pcUnderflow(false);\n        pcOverflow(false);\n        pcAtHalt(false);\n        pcAtBarrier(false);\n        pcAtNoOp(false);\n    } /**\n       * this function sets all flags related to pc\n       * such as pcOverflow and pcHitBarrier, etc\n       */\n\n    function updatePcStatus() {\n        pcUnderflow(PQ.processCounter < 0);\n        pcOverflow(PQ.processCounter >= PQ.processStack.length);\n        pcAtHalt(PQ.nextProcess === PQUEUE_HALT);\n        pcAtBarrier(PQ.nextProcess === PQUEUE_BARRIER);\n        pcAtNoOp(typeof PQ.nextProcess !== 'function');\n        queueError(pcUnderflow() || pcOverflow() || pcAtNoOp());\n    } // >>> status related functions\n    // <<< pc related functions\n    /**\n     * these functions should call updatePcStatus()\n     */\n\n    function pcGoto(newPc) {\n        if (typeof newPc !== 'number') return;\n        PQ.processCounter = newPc;\n        PQ.nextProcess = PQ.processStack[PQ.processCounter];\n        updatePcStatus();\n    }\n\n    function pcIncrement() {\n        // halt when in error\n        if (queueError()) return;\n        pcGoto(PQ.processCounter + 1);\n    }\n\n    function pcDecrement() {\n        // halt when in error\n        if (queueError()) return;\n        pcGoto(PQ.processCounter - 1);\n    }\n\n    function pcOffset(offset) {\n        if (typeof offset !== 'number') return;\n        PQ.processCounter += offset;\n        PQ.nextProcess = PQ.processStack[PQ.processCounter];\n        updatePcStatus();\n    }\n\n    function pcReference(funcName) {\n        var index = PQ.processIndexs[String(funcName)];\n        return typeof index === 'number' ? index : -1;\n    }\n\n    function valueOfPC() {\n        return PQ.processCounter;\n    }\n\n    function PCtoString() {\n        return typeof PQ.nextProcess === 'function' ? PQ.nextProcess.name : String(PQ.processCounter);\n    } // >>> pc related functions\n\n\n    function fireError(message) {\n        queueError(true);\n        PQ.errorMessages.push(typeof message === 'string' ? message : '');\n    }\n\n    function throwErrors() {\n        warn('pcUnderflow: ' + Boolean(pcUnderflow()));\n        warn('pcOverflow: ' + Boolean(pcOverflow()));\n        warn('pcAtNoOp: ' + Boolean(pcAtNoOp()));\n        warn('pcAtHalt: ' + Boolean(pcAtHalt()));\n        warn('pcAtBarrier: ' + Boolean(pcAtBarrier()));\n\n        while (PQ.errorMessages.length > 0) {\n            warn(PQ.errorMessages.shift());\n        } // clear error flag?\n\n    } /* interface functions */ /**\n                                 * this function starts this queue\n                                 * and sets the flag 'booted'\n                                 * a booted queue can not be booted\n                                 * again, unless it has been halted\n                                 */\n\n    function bootQueue() {\n        // check flag\n        if (queueIsBooted()) return; // set flag\n\n        queueIsBooted(true);\n        log('[' + PQ.name + '].boot');\n        enableClock();\n    } /**\n       * this function kills this queue\n       * and clears the flag 'booted'\n       * it has no effect on an un-activated queue\n       */\n\n    function haltQueue() {\n        // check flag\n        if (!queueIsBooted()) return; // set flag\n\n        queueIsBooted(false);\n        log('[' + PQ.name + '].halt');\n        disableClock();\n    } /**\n       * this function resets PC and heap (optional)\n       * a booted queue can not be reset\n       * added in 2.4.2\n       */\n\n    function resetQueue(clearHeap) {\n        // check flag\n        if (queueIsBooted()) return;\n        log('[' + PQ.name + '].reset');\n        pcGoto(initialProcessID);\n        if (clearHeap) cleanSharedHeap();\n    } /**\n       * proceed to next process\n       */\n\n    function tick() {\n        // check flags\n        // a queue has to be booted first\n        if (!queueIsBooted()) return; // skip ticks while the queue is paused\n\n        if (queueIsPaused()) return; // prevent other ticks from interfering\n\n        if (queueIsTicking()) return; // set flag\n\n        queueIsTicking(true);\n        log('[' + PQ.name + '].tick'); // check if there was an error previously\n\n        if (queueError()) {\n            warn('Has error(s)'); // is not ticking\n\n            queueIsTicking(false); // throw errors\n\n            throwErrors(); // halt queue\n\n            haltQueue();\n            return;\n        }\n\n        if (pcAtHalt()) {\n            // is not ticking\n            queueIsTicking(false); // halt queue\n\n            haltQueue();\n            return;\n        } /**\n           * No need to verify PC value or process\n           * since every pc modification will\n           * also check the pc range and process\n           * and set flags accordingly, so the \n           * previous error check is enough.\n           */ // -- verify PC value\n        // -- verify process\n        // fetch process\n\n\n        var thePC = PQ.processCounter,\n            theProcess = PQ.nextProcess; /**\n                                          * mimic the behavior of a processor, \n                                          * increment the process counter before\n                                          * executing\n                                          * this step should also fire any error\n                                          * if pc goes out of range and these errors\n                                          * will be processed later\n                                          */\n        pcIncrement();\n        log('PC:' + thePC + '>>' + theProcess.name); // set running flag\n\n        queueIsRunning(true); /**\n                               * pass wrapped api over so client script\n                               * can not harm core objects\n                               */\n\n        try {\n            theProcess.call(api, api, api.heap);\n        } catch (e) {\n            fireError(e.message);\n        } // clear running flag\n\n\n        queueIsRunning(false);\n        queueIsTicking(false);\n    } /**\n       * queue pausing mechanism\n       */\n\n    function appendWaker(time) {\n        PQ.wakerStack.push(setTimeout(api.resume, time));\n    }\n\n    function removeWakers() {\n        while (PQ.wakerStack.length > 0) {\n            clearTimeout(PQ.wakerStack.shift());\n        }\n    }\n\n    function pauseQueue(time) {\n        // check flag\n        if (!queueIsBooted()) return;\n        if (queueIsPaused()) return;\n        queueIsPaused(true); // disable clock\n\n        disableClock();\n        if (typeof time === 'number') appendWaker(time);\n    }\n\n    function resumeQueue() {\n        // check flag\n        if (!queueIsBooted()) return;\n        if (!queueIsPaused()) return;\n        queueIsPaused(false);\n        removeWakers();\n        enableClock();\n    } // append processes\n\n\n    for (var i = 0, n = processArray.length; i < n; ++i) {\n        var process = processArray[i];\n        var name = process.name;\n        var index = PQ.processStack.length;\n        PQ.processStack.push(process);\n        if (name !== '') PQ.processIndexs[name] = index;\n    } // set pc\n\n\n    pcGoto(initialProcessID); // set name\n\n    if (typeof queueName === 'string' && queueName !== '') {\n        PQ.name = queueName; // insert into record only if the name is specified\n\n        queueStack[queueName] = api;\n    } else {\n        PQ.name = String(new Date().getTime());\n    }\n\n    return wrapper;\n},\n    core_version = '2.4.3',\n    PQUEUE_HALT = function PQUEUE_HALT() {},\n    PQUEUE_BARRIER = function PQUEUE_BARRIER(queue) {\n    queue.pause();\n},\n    PQUEUE_IDLE = function PQUEUE_IDLE(queue) {\n    queue.pause(); // pc offset -1 so this process will be executed again on next resume()\n\n    queue.pc.offset(-1);\n}; // store version\n\n\nObject.defineProperty(PQUEUE, \"PQUEUE\", {\n    configurable: false,\n    enumerable: false,\n    value: core_version,\n    writable: false\n}); // Bind constants\n\nObject.defineProperty(PQUEUE, \"HALT\", {\n    configurable: false,\n    enumerable: false,\n    value: PQUEUE_HALT,\n    writable: false\n});\nObject.defineProperty(PQUEUE, \"BARRIER\", {\n    configurable: false,\n    enumerable: false,\n    value: PQUEUE_BARRIER,\n    writable: false\n});\nObject.defineProperty(PQUEUE, \"IDLE\", {\n    configurable: false,\n    enumerable: false,\n    value: PQUEUE_IDLE,\n    writable: false\n}); // export\n\nmodule.exports = PQUEUE;","map":{"version":3,"sources":["packages/zodiase:mdl-assets/scripts/imports/pqueue.js"],"names":["microtime","get_as_float","now","Date","getTime","s","parseInt","Math","round","startTime","elapsedTime","log","msg","console","toString","substr","warn","isArray","obj","constructor","name","queueStack","PQUEUE","parent","processArray","initialProcessID","queueName","arg1Type","arguments","arg2Type","arg3Type","arg4Type","length","PQ","FLAG_RUNNING","FLAG_TICKING","FLAG_BOOTED","FLAG_PAUSED","FLAG_GENERR","FLAG_PCUNDER","FLAG_PCOVER","FLAG_PCHALT","FLAG_PCBAR","FLAG_PCNOOP","api","sharedHeap","dumpSharedHeap","time","queueIsRunning","queueIsPaused","pauseQueue","resumeQueue","pcIncrement","pcDecrement","pcOffset","pcGoto","pcReference","valueOfPC","PCtoString","wrapper","bootQueue","haltQueue","resetQueue","enableClock","clock","setInterval","tick","disableClock","clearInterval","result","key","cleanSharedHeap","_statIs","setValue","flag","returnValue","Boolean","status","undefined","queueIsTicking","queueIsBooted","queueError","pcUnderflow","pcOverflow","pcAtHalt","pcAtBarrier","pcAtNoOp","clearPcStatus","updatePcStatus","processCounter","processStack","nextProcess","PQUEUE_HALT","PQUEUE_BARRIER","newPc","offset","funcName","index","processIndexs","String","fireError","message","errorMessages","push","throwErrors","shift","clearHeap","thePC","theProcess","call","heap","e","appendWaker","wakerStack","setTimeout","resume","removeWakers","clearTimeout","i","n","process","core_version","queue","pause","PQUEUE_IDLE","pc","Object","defineProperty","configurable","enumerable","value","writable","module","exports"],"mappings":"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","file":"packages/zodiase:mdl-assets/scripts/imports/pqueue.js.map","sourcesContent":["/*!\r\n * Process Queue v2.4.3 r1\r\n * https://github.com/Zodiase/PQUEUE\r\n *\r\n * Copyright 2013 Xingchen Hong\r\n * Released under the MIT license\r\n * https://raw.github.com/Zodiase/PQUEUE/master/LICENSE\r\n *\r\n * Date: 2014-02-09 10:03\r\n */\r\n/*\r\nChange Log:\r\n     Fixed a bug when connecting to a parent.\r\n     Added a predefined process PQUEUE_IDLE for easy access.\r\n     Added an option to turn off console logs.\r\n*/\r\n// add ';' to seperate from previous code clips.\r\n\nfunction microtime(get_as_float) {\n    var now = new Date().getTime() / 1000;\n    var s = parseInt(now, 10);\n    return (get_as_float) ? now : (Math.round((now - s) * 1000) / 1000) + ' ' + s;\n}\nvar startTime = microtime(true);\nfunction elapsedTime() {\n    return microtime(true) - startTime;\n}\nfunction log(msg) {\n    console.log('@' + (elapsedTime().toString(10) + '        ').substr(0,8) + ', PQUEUE: ' + msg);\n}\nfunction warn(msg) {\n    console.warn('@' + (elapsedTime().toString(10) + '        ').substr(0,8) + ', PQUEUE: ' + msg);\n}\nfunction isArray(obj) {\n    if (typeof obj !== 'object') return false;\n    if (typeof obj.constructor !== 'function') return false;\n    if (typeof obj.constructor.name !== 'string') return false;\n    return (obj.constructor.name === 'Array');\n}\n// a stack for back-track to queues\nvar queueStack = [];\n// this function returns a pqueue object\nvar PQUEUE = function () {\n    \"use strict\";\n    var parent = null,\n        processArray = [],\n        initialProcessID = 0,\n        queueName = '',\n        arg1Type = typeof arguments[0],\n        arg2Type = typeof arguments[1],\n        arg3Type = typeof arguments[2],\n        arg4Type = typeof arguments[3];\n    switch (arguments.length) {\n        case 1:\n            if (arg1Type === 'string') {\n                // PQUEUE(string queueName)\n                return queueStack[arguments[0]];\n            } else if (arg1Type === 'object') {\n                if (isArray(arguments[0])) {\n                    // PQUEUE(object processArray)\n                    processArray = arguments[0];\n                } else if (isArray(arguments[0].processArray)) {\n                    parent = (typeof arguments[0].parent === 'object') ? arguments[0].parent : null;\n                    processArray = arguments[0].processArray;\n                    initialProcessID = (typeof arguments[0].initialProcessID === 'number') ? arguments[0].initialProcessID : 0;\n                    queueName = (typeof arguments[0].queueName === 'string') ? arguments[0].queueName : '';\n                } else {\n                    return null;\n                }\n            } else {\n                return null;\n            }\n            break;\n        case 2:\n            if (arg1Type === 'object' && arg2Type === 'object') {\n                // PQUEUE(object parentQueue, object processArray)\n                parent = arguments[0];\n                processArray = arguments[1];\n                initialProcessID = 0;\n                queueName = '';\n            } else if (arg1Type === 'object' && arg2Type === 'number') {\n                // PQUEUE(object processArray, number initialProcessID)\n                parent = null;\n                processArray = arguments[0];\n                initialProcessID = arguments[1];\n                queueName = '';\n            } else if (arg1Type === 'object' && arg2Type === 'string') {\n                // PQUEUE(object processArray, string queueName)\n                parent = null;\n                processArray = arguments[0];\n                initialProcessID = 0;\n                queueName = arguments[1];\n            } else {\n                return null;\n            }\n            break;\n        case 3:\n            if (arg1Type === 'object' && arg2Type === 'object' && arg3Type === 'number') {\n                // PQUEUE(object parentQueue, object processArray, number initialProcessID)\n                parent = arguments[0];\n                processArray = arguments[1];\n                initialProcessID = arguments[2];\n                queueName = '';\n            } else if (arg1Type === 'object' && arg2Type === 'object' && arg3Type === 'string') {\n                // PQUEUE(object parentQueue, object processArray, string queueName)\n                parent = arguments[0];\n                processArray = arguments[1];\n                initialProcessID = 0;\n                queueName = arguments[2];\n            } else if (arg1Type === 'object' && arg2Type === 'number' && arg3Type === 'string') {\n                // PQUEUE(object processArray, number initialProcessID, string queueName)\n                parent = null;\n                processArray = arguments[0];\n                initialProcessID = arguments[1];\n                queueName = arguments[2];\n            } else {\n                return null;\n            }\n            break;\n        case 4:\n            if (arg1Type === 'object' && arg2Type === 'object' && arg3Type === 'number' && arg4Type === 'string') {\n                // PQUEUE(object parentQueue, object processArray, number initialProcessID, string queueName)\n                parent = arguments[0];\n                processArray = arguments[1];\n                initialProcessID = arguments[2];\n                queueName = arguments[3];\n            } else {\n                return null;\n            }\n            break;\n        default:\n            return null;\n    }\n    // filter init process id\n    if (typeof initialProcessID !== 'number')\n        initialProcessID = 0;\n    log('Instantiating new process queue.');\n    // parameter check\n    if (typeof processArray !== 'object') {\n        warn('Invalid argument[1]. Expecting an Object.');\n        warn('Returning NULL.');\n        // 'return;' returns undefined\n        return null;\n    }\n    log('Generating new process queue object.');\n    // local copy of core data\n    var PQ = {\n        // core clock used to fire ticks\n        'clock': false,\n        // back reference to its parent queue if available\n        'parent': (parent && typeof parent === 'object' && parent.PQUEUE) ? parent : null,\n        // name of queue\n        'name': '',\n        /**\n         * flags indicating queue status\n         *     bit[0]  indicates a process is running\n         *     bit[1]  indicates the queue is handling one tick\n         *     bit[2]  indicates the queue is booted up but not yet stopped\n         *     bit[3]  indicates the queue should get to the next process automatically\n         *     bit[4]  indicates the queue is paused and waiting for a resume call\n         *     bit[5]  indicates a general error\n         *     bit[6]  indicates pc underflow\n         *     bit[7]  indicates pc overflow\n         *     bit[8]  indicates pc at halt\n         *     bit[9]  indicates pc at barrier\n         *     bit[10] indicates pc at no-op\n         */\n        'status': 0,\n        // message array for errors\n        'errorMessages': [],\n        // array of processes\n        'processStack': [],\n        // fully-associative array used to find the index of a process\n        'processIndexs': [],\n        // index of the next process\n        'processCounter': 0,\n        // pointer to the next process\n        'nextProcess': null,\n        // storage for processes\n        'sharedHeap': {},\n        /**\n         * waker stack is used to store resume call timers so that\n         * when a resume call is called before the timer expires,\n         * the rest timer won't affect the queue\n         */\n        'wakerStack': []\n    },\n    // flag constants\n    FLAG_RUNNING = 0x001, // 0000 0000 0001\n    FLAG_TICKING = 0x002, // 0000 0000 0010\n    FLAG_BOOTED  = 0x004, // 0000 0000 0100\n    FLAG_PAUSED  = 0x008, // 0000 0000 1000\n    \n    FLAG_GENERR  = 0x010, // 0000 0001 0000\n    FLAG_PCUNDER = 0x020, // 0000 0010 0000\n    FLAG_PCOVER  = 0x040, // 0000 0100 0000\n    FLAG_PCHALT  = 0x080, // 0000 1000 0000\n    FLAG_PCBAR   = 0x100, // 0001 0000 0000\n    FLAG_PCNOOP  = 0x200, // 0010 0000 0000\n    \n    // interface object passed to processes\n    api = {\n        'heap': PQ.sharedHeap,\n        'heap_dump': dumpSharedHeap,\n        'pause': function (time) {\n            /**\n             * a wait call can only be made when the process is executing\n             * and it should not be made twice\n             */\n            if (queueIsRunning() && !queueIsPaused()) pauseQueue(time);\n        },\n        'resume': function () {\n            /**\n             * however, a resume call can be made within the process right\n             * after the pause call, or, at a later time\n             * a resume call only clears the pause flag so that the clock\n             * is again effective to the queue\n             */\n            if (queueIsPaused()) resumeQueue();\n        },\n        'pc': {\n            'increment': pcIncrement,\n            'decrement': pcDecrement,\n            'offset': pcOffset,\n            'goto': pcGoto,\n            'locate': pcReference,\n            'valueOf': valueOfPC,\n            'toString': PCtoString\n        },\n        'isPaused': function () {\n            return queueIsPaused();\n        },\n        // the so-called parent is actually the api object of the parent queue\n        'parent': PQ.parent,\n        // this is necessary for parent check to recognize a pqueue object\n        'PQUEUE': true\n    },\n    // wrapper object returned to parent scripts\n    wrapper = {\n        'boot': function () {\n            bootQueue();\n            return wrapper;\n        },\n        'halt': function () {\n            haltQueue();\n            return wrapper;\n        },\n        'reset': function () {\n            resetQueue();\n            return wrapper;\n        }\n    };\n    /* macro functions */\n    // clock related functions\n    function enableClock() {\n        if (PQ.clock === false) {\n            // keep calling tick as fast as possible\n            PQ.clock = setInterval(tick, 0);\n        }\n    }\n    function disableClock() {\n        if (PQ.clock !== false) {\n            // stop queue clock\n            clearInterval(PQ.clock);\n            PQ.clock = false;\n        }\n    }\n    // heap related functions\n    /**\n     * this function returns a string representing\n     * contents in shared heap\n     */\n    function dumpSharedHeap() {\n        var result = '';\n        for (var key in PQ.sharedHeap) {\n            if (result !== '') result += ', \\n';\n            result += key + ':' + PQ.sharedHeap[key];\n        }\n        return '{\\n' + result + '\\n}';\n    }\n    /**\n     * this function removes everything in the heap\n     */\n    function cleanSharedHeap() {\n        // may cause memory leak but let's keep it this way for now\n        PQ.sharedHeap.length = 0;\n    }\n    // <<< status related functions\n    /**\n     * this the core function handling status bits\n     * the rest are macros using this function\n     */\n    function _statIs(setValue, flag) {\n        var returnValue = Boolean(PQ.status & flag);\n        if (setValue !== undefined) {\n            if (setValue) PQ.status |= flag;\n            else PQ.status &= ~flag;\n        }\n        return returnValue;\n    }\n    function queueIsRunning(setValue) {\n        return _statIs(setValue, FLAG_RUNNING);\n    }\n    function queueIsTicking(setValue) {\n        return _statIs(setValue, FLAG_TICKING);\n    }\n    function queueIsBooted(setValue) {\n        return _statIs(setValue, FLAG_BOOTED);\n    }\n    function queueIsPaused(setValue) {\n        return _statIs(setValue, FLAG_PAUSED);\n    }\n    function queueError(setValue) {\n        return _statIs(setValue, FLAG_GENERR);\n    }\n    function pcUnderflow(setValue) {\n        return _statIs(setValue, FLAG_PCUNDER);\n    }\n    function pcOverflow(setValue) {\n        return _statIs(setValue, FLAG_PCOVER);\n    }\n    function pcAtHalt(setValue) {\n        return _statIs(setValue, FLAG_PCHALT);\n    }\n    function pcAtBarrier(setValue) {\n        return _statIs(setValue, FLAG_PCBAR);\n    }\n    function pcAtNoOp(setValue) {\n        return _statIs(setValue, FLAG_PCNOOP);\n    }\n    /**\n     * this function clears all flags related to pc\n     * such as pcOverflow and pcHitBarrier, etc\n     */\n    function clearPcStatus() {\n        pcUnderflow (false);\n        pcOverflow  (false);\n        pcAtHalt    (false);\n        pcAtBarrier (false);\n        pcAtNoOp    (false);\n    }\n    /**\n     * this function sets all flags related to pc\n     * such as pcOverflow and pcHitBarrier, etc\n     */\n    function updatePcStatus() {\n        pcUnderflow (PQ.processCounter < 0);\n        pcOverflow  (PQ.processCounter >= PQ.processStack.length);\n        pcAtHalt    (PQ.nextProcess === PQUEUE_HALT);\n        pcAtBarrier (PQ.nextProcess === PQUEUE_BARRIER);\n        pcAtNoOp    (typeof PQ.nextProcess !== 'function');\n        queueError  (pcUnderflow() || pcOverflow() || pcAtNoOp());\n    }\n    // >>> status related functions\n    // <<< pc related functions\n    /**\n     * these functions should call updatePcStatus()\n     */\n    function pcGoto(newPc) {\n        if (typeof newPc !== 'number') return;\n        PQ.processCounter = newPc;\n        PQ.nextProcess = PQ.processStack[PQ.processCounter];\n        updatePcStatus();\n    }\n    function pcIncrement() {\n        // halt when in error\n        if (queueError()) return;\n        pcGoto(PQ.processCounter + 1);\n    }\n    function pcDecrement() {\n        // halt when in error\n        if (queueError()) return;\n        pcGoto(PQ.processCounter - 1);\n    }\n    function pcOffset(offset) {\n        if (typeof offset !== 'number') return;\n        PQ.processCounter += offset;\n        PQ.nextProcess = PQ.processStack[PQ.processCounter];\n        updatePcStatus();\n    }\n    function pcReference(funcName) {\n        var index = PQ.processIndexs[String(funcName)];\n        return (typeof index === 'number') ? index : -1;\n    }\n    function valueOfPC() {\n        return PQ.processCounter;\n    }\n    function PCtoString() {\n        return (typeof PQ.nextProcess === 'function') ? PQ.nextProcess.name : String(PQ.processCounter);\n    }\n    // >>> pc related functions\n    function fireError(message) {\n        queueError(true);\n        PQ.errorMessages.push((typeof message === 'string') ? message : '');\n    }\n    function throwErrors() {\n        warn('pcUnderflow: ' + Boolean(pcUnderflow()));\n        warn('pcOverflow: ' + Boolean(pcOverflow()));\n        warn('pcAtNoOp: ' + Boolean(pcAtNoOp()));\n        warn('pcAtHalt: ' + Boolean(pcAtHalt()));\n        warn('pcAtBarrier: ' + Boolean(pcAtBarrier()));\n        while (PQ.errorMessages.length > 0) {\n            warn(PQ.errorMessages.shift());\n        }\n        // clear error flag?\n    }\n    /* interface functions */\n    /**\n     * this function starts this queue\n     * and sets the flag 'booted'\n     * a booted queue can not be booted\n     * again, unless it has been halted\n     */\n    function bootQueue() {\n        // check flag\n        if (queueIsBooted()) return;\n        // set flag\n        queueIsBooted(true);\n        log('[' + PQ.name + '].boot');\n        enableClock();\n    }\n    /**\n     * this function kills this queue\n     * and clears the flag 'booted'\n     * it has no effect on an un-activated queue\n     */\n    function haltQueue() {\n        // check flag\n        if (!queueIsBooted()) return;\n        // set flag\n        queueIsBooted(false);\n        log('[' + PQ.name + '].halt');\n        disableClock();\n    }\n    /**\n     * this function resets PC and heap (optional)\n     * a booted queue can not be reset\n     * added in 2.4.2\n     */\n     function resetQueue(clearHeap) {\n        // check flag\n        if (queueIsBooted()) return;\n        log('[' + PQ.name + '].reset');\n        pcGoto(initialProcessID);\n        if (clearHeap)\n            cleanSharedHeap();\n     }\n    /**\n     * proceed to next process\n     */\n    function tick() {\n        // check flags\n        // a queue has to be booted first\n        if (!queueIsBooted()) return;\n        // skip ticks while the queue is paused\n        if (queueIsPaused()) return;\n        // prevent other ticks from interfering\n        if (queueIsTicking()) return;\n        // set flag\n        queueIsTicking(true);\n        log('[' + PQ.name + '].tick');\n        // check if there was an error previously\n        if (queueError()) {\n            warn('Has error(s)');\n            // is not ticking\n            queueIsTicking(false);\n            // throw errors\n            throwErrors();\n            // halt queue\n            haltQueue();\n            return;\n        }\n        if (pcAtHalt()) {\n            // is not ticking\n            queueIsTicking(false);\n            // halt queue\n            haltQueue();\n            return;\n        }\n        /**\n         * No need to verify PC value or process\n         * since every pc modification will\n         * also check the pc range and process\n         * and set flags accordingly, so the \n         * previous error check is enough.\n         */\n        // -- verify PC value\n        // -- verify process\n        // fetch process\n        var thePC = PQ.processCounter,\n            theProcess = PQ.nextProcess;\n        /**\n         * mimic the behavior of a processor, \n         * increment the process counter before\n         * executing\n         * this step should also fire any error\n         * if pc goes out of range and these errors\n         * will be processed later\n         */\n        pcIncrement();\n        log('PC:' + thePC + '>>' + theProcess.name);\n        // set running flag\n        queueIsRunning(true);\n        /**\n         * pass wrapped api over so client script\n         * can not harm core objects\n         */\n        try {\n            theProcess.call(api, api, api.heap);\n        } catch (e) {\n            fireError(e.message);\n        }\n        // clear running flag\n        queueIsRunning(false);\n        queueIsTicking(false);\n    }\n    /**\n     * queue pausing mechanism\n     */\n    function appendWaker(time) {\n        PQ.wakerStack.push(setTimeout(api.resume, time));\n    }\n    function removeWakers() {\n        while (PQ.wakerStack.length > 0) {\n            clearTimeout(PQ.wakerStack.shift());\n        }\n    }\n    function pauseQueue(time) {\n        // check flag\n        if (!queueIsBooted()) return;\n        if (queueIsPaused()) return;\n        queueIsPaused(true);\n        // disable clock\n        disableClock();\n        if (typeof time === 'number') appendWaker(time);\n    }\n    function resumeQueue() {\n        // check flag\n        if (!queueIsBooted()) return;\n        if (!queueIsPaused()) return;\n        queueIsPaused(false);\n        removeWakers();\n        enableClock();\n    }\n    // append processes\n    for (var i = 0, n = processArray.length; i < n; ++i) {\n        var process = processArray[i];\n        var name = process.name;\n        var index = PQ.processStack.length;\n        PQ.processStack.push(process);\n        if (name !== '') PQ.processIndexs[name] = index;\n    }\n    // set pc\n    pcGoto(initialProcessID);\n    // set name\n    if (typeof queueName === 'string' && queueName !== '') {\n        PQ.name = queueName;\n        // insert into record only if the name is specified\n        queueStack[queueName] = api;\n    } else {\n        PQ.name = String((new Date()).getTime());\n    }\n    return wrapper;\n},\ncore_version = '2.4.3',\nPQUEUE_HALT = function PQUEUE_HALT() {},\nPQUEUE_BARRIER = function PQUEUE_BARRIER(queue) {\n    queue.pause();\n},\nPQUEUE_IDLE = function PQUEUE_IDLE(queue) {\n    queue.pause();\n    // pc offset -1 so this process will be executed again on next resume()\n    queue.pc.offset(-1);\n};\n\n// store version\nObject.defineProperty(PQUEUE, \"PQUEUE\", {\n    configurable: false,\n    enumerable: false,\n    value: core_version,\n    writable: false\n});\n\n// Bind constants\nObject.defineProperty(PQUEUE, \"HALT\", {\n    configurable: false,\n    enumerable: false,\n    value: PQUEUE_HALT,\n    writable: false\n});\nObject.defineProperty(PQUEUE, \"BARRIER\", {\n    configurable: false,\n    enumerable: false,\n    value: PQUEUE_BARRIER,\n    writable: false\n});\nObject.defineProperty(PQUEUE, \"IDLE\", {\n    configurable: false,\n    enumerable: false,\n    value: PQUEUE_IDLE,\n    writable: false\n});\n\n// export\nmodule.exports = PQUEUE;"]},"hash":"92b8361bd64b57bb36642cd90b7d80369b5f27af"}
