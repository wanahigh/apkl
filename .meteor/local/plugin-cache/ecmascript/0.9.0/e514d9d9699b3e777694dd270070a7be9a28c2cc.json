{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/http/httpcall_server.js","filenameRelative":"packages/http/httpcall_server.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/http/httpcall_server.js.map","sourceFileName":"packages/http/httpcall_server.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"httpcall_server"},"ignored":false,"code":"var path = Npm.require('path');\n\nvar request = Npm.require('request');\n\nvar url_util = Npm.require('url');\n\nHTTPInternals = {\n  NpmModules: {\n    request: {\n      version: Npm.require('request/package.json').version,\n      module: request\n    }\n  }\n}; // _call always runs asynchronously; HTTP.call, defined below,\n// wraps _call and runs synchronously when no callback is provided.\n\nvar _call = function (method, url, options, callback) {\n  ////////// Process arguments //////////\n  if (!callback && typeof options === \"function\") {\n    // support (method, url, callback) argument list\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n\n  if (_.has(options, 'beforeSend')) {\n    throw new Error(\"Option beforeSend not supported on server.\");\n  }\n\n  method = (method || \"\").toUpperCase();\n  if (!/^https?:\\/\\//.test(url)) throw new Error(\"url must be absolute and start with http:// or https://\");\n  var headers = {};\n  var content = options.content;\n\n  if (options.data) {\n    content = JSON.stringify(options.data);\n    headers['Content-Type'] = 'application/json';\n  }\n\n  var paramsForUrl, paramsForBody;\n  if (content || method === \"GET\" || method === \"HEAD\") paramsForUrl = options.params;else paramsForBody = options.params;\n\n  var newUrl = URL._constructUrl(url, options.query, paramsForUrl);\n\n  if (options.auth) {\n    if (options.auth.indexOf(':') < 0) throw new Error('auth option should be of the form \"username:password\"');\n    headers['Authorization'] = \"Basic \" + Buffer.from(options.auth, \"ascii\").toString(\"base64\");\n  }\n\n  if (paramsForBody) {\n    content = URL._encodeParams(paramsForBody);\n    headers['Content-Type'] = \"application/x-www-form-urlencoded\";\n  }\n\n  _.extend(headers, options.headers || {}); // wrap callback to add a 'response' property on an error, in case\n  // we have both (http 4xx/5xx error, which has a response payload)\n\n\n  callback = function (callback) {\n    return function (error, response) {\n      if (error && response) error.response = response;\n      callback(error, response);\n    };\n  }(callback); // safety belt: only call the callback once.\n\n\n  callback = _.once(callback); ////////// Kickoff! //////////\n  // Allow users to override any request option with the npmRequestOptions\n  // option.\n\n  var reqOptions = _.extend({\n    url: newUrl,\n    method: method,\n    encoding: \"utf8\",\n    jar: false,\n    timeout: options.timeout,\n    body: content,\n    followRedirect: options.followRedirects,\n    // Follow redirects on non-GET requests\n    // also. (https://github.com/meteor/meteor/issues/2808)\n    followAllRedirects: options.followRedirects,\n    headers: headers\n  }, options.npmRequestOptions || {});\n\n  request(reqOptions, function (error, res, body) {\n    var response = null;\n\n    if (!error) {\n      response = {};\n      response.statusCode = res.statusCode;\n      response.content = body;\n      response.headers = res.headers;\n      populateData(response);\n      if (response.statusCode >= 400) error = makeErrorByStatus(response.statusCode, response.content);\n    }\n\n    callback(error, response);\n  });\n};\n\nHTTP.call = Meteor.wrapAsync(_call);","map":{"version":3,"sources":["packages/http/httpcall_server.js"],"names":["path","Npm","require","request","url_util","HTTPInternals","NpmModules","version","module","_call","method","url","options","callback","_","has","Error","toUpperCase","test","headers","content","data","JSON","stringify","paramsForUrl","paramsForBody","params","newUrl","URL","_constructUrl","query","auth","indexOf","Buffer","from","toString","_encodeParams","extend","error","response","once","reqOptions","encoding","jar","timeout","body","followRedirect","followRedirects","followAllRedirects","npmRequestOptions","res","statusCode","populateData","makeErrorByStatus","HTTP","call","Meteor","wrapAsync"],"mappings":"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","file":"packages/http/httpcall_server.js.map","sourcesContent":["var path = Npm.require('path');\nvar request = Npm.require('request');\nvar url_util = Npm.require('url');\n\nHTTPInternals = {\n  NpmModules: {\n    request: {\n      version: Npm.require('request/package.json').version,\n      module: request\n    }\n  }\n};\n\n// _call always runs asynchronously; HTTP.call, defined below,\n// wraps _call and runs synchronously when no callback is provided.\nvar _call = function(method, url, options, callback) {\n\n  ////////// Process arguments //////////\n\n  if (! callback && typeof options === \"function\") {\n    // support (method, url, callback) argument list\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n\n  if (_.has(options, 'beforeSend')) {\n    throw new Error(\"Option beforeSend not supported on server.\");\n  }\n\n  method = (method || \"\").toUpperCase();\n\n  if (! /^https?:\\/\\//.test(url))\n    throw new Error(\"url must be absolute and start with http:// or https://\");\n\n  var headers = {};\n\n  var content = options.content;\n  if (options.data) {\n    content = JSON.stringify(options.data);\n    headers['Content-Type'] = 'application/json';\n  }\n\n\n  var paramsForUrl, paramsForBody;\n  if (content || method === \"GET\" || method === \"HEAD\")\n    paramsForUrl = options.params;\n  else\n    paramsForBody = options.params;\n\n  var newUrl = URL._constructUrl(url, options.query, paramsForUrl);\n\n  if (options.auth) {\n    if (options.auth.indexOf(':') < 0)\n      throw new Error('auth option should be of the form \"username:password\"');\n    headers['Authorization'] = \"Basic \"+\n      Buffer.from(options.auth, \"ascii\").toString(\"base64\");\n  }\n\n  if (paramsForBody) {\n    content = URL._encodeParams(paramsForBody);\n    headers['Content-Type'] = \"application/x-www-form-urlencoded\";\n  }\n\n  _.extend(headers, options.headers || {});\n\n  // wrap callback to add a 'response' property on an error, in case\n  // we have both (http 4xx/5xx error, which has a response payload)\n  callback = (function(callback) {\n    return function(error, response) {\n      if (error && response)\n        error.response = response;\n      callback(error, response);\n    };\n  })(callback);\n\n  // safety belt: only call the callback once.\n  callback = _.once(callback);\n\n\n  ////////// Kickoff! //////////\n\n  // Allow users to override any request option with the npmRequestOptions\n  // option.\n  var reqOptions = _.extend({\n    url: newUrl,\n    method: method,\n    encoding: \"utf8\",\n    jar: false,\n    timeout: options.timeout,\n    body: content,\n    followRedirect: options.followRedirects,\n    // Follow redirects on non-GET requests\n    // also. (https://github.com/meteor/meteor/issues/2808)\n    followAllRedirects: options.followRedirects,\n    headers: headers\n  }, options.npmRequestOptions || {});\n\n  request(reqOptions, function(error, res, body) {\n    var response = null;\n\n    if (! error) {\n\n      response = {};\n      response.statusCode = res.statusCode;\n      response.content = body;\n      response.headers = res.headers;\n\n      populateData(response);\n\n      if (response.statusCode >= 400)\n        error = makeErrorByStatus(response.statusCode, response.content);\n    }\n\n    callback(error, response);\n\n  });\n};\n\nHTTP.call = Meteor.wrapAsync(_call);\n"]},"hash":"e514d9d9699b3e777694dd270070a7be9a28c2cc"}
